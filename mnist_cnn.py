# -*- coding: utf-8 -*-
"""Mnist_CNN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n6VVM-CVAbroPYam9qYw4V5QxgsJVeLR
"""

# Commented out IPython magic to ensure Python compatibility.
import warnings
warnings.filterwarnings('ignore')

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

import tensorflow as tf
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D
from keras.callbacks import ModelCheckpoint
(X_train, Y_train), (X_test, Y_test) = keras.datasets.mnist.load_data()
X_valid = X_train[50000:]
Y_valid = Y_train[50000:]

X_train = X_train[:50000]
Y_train = Y_train[:50000]
print(f'SHAPE OF X_train = {X_train.shape} AND Y_train = {Y_train.shape}')
print(f'SHAPE OF X_valid = {X_valid.shape} AND Y_valid = {Y_valid.shape}')
print(f'SHAPE OF X_test  = {X_test.shape} AND Y_test  = {Y_test.shape}')
fig = plt.figure(figsize = (15, 10))
for i in range(1, (3*5)+1):
    rn = np.random.randint(50000)
    fig.add_subplot(3, 5, i)
    plt.imshow(X_train[rn], cmap='gray')
    plt.xlabel(Y_train[rn], color='green')

plt.show()
X_train = X_train / 255
X_valid = X_valid / 255
X_test = X_test / 255
print(X_train.shape)
Y_test = [i for i in Y_test]
model = Sequential([
    Conv2D(filters=32, kernel_size=(5,5), activation='relu', input_shape=(28, 28, 1)),
    MaxPooling2D(pool_size=(2,2)),
    
    Conv2D(filters=64, kernel_size=(3,3), activation='relu'),
    MaxPooling2D(pool_size=(2,2)),
    
    Conv2D(filters=32, kernel_size=(3,3), activation='relu'),
    MaxPooling2D(pool_size=(2,2)),
    
    Flatten(),

    Dense(32, activation='relu'),
    Dense(64, activation='relu'),
    Dense(32, activation='relu'),
    Dense(10, activation='softmax')
])
opt = ['adam', 'rmsprop', 'adadelta', 'adagrad', 'sgd']
for i in opt:
    model.compile(optimizer=i, loss='sparse_categorical_crossentropy', metrics=['accuracy'])
    model.fit(X_train, Y_train, epochs=10, validation_data=(X_valid, Y_valid), verbose=0)
    print()
    Y_pred = model.predict(X_test)
    Y_pred = [np.argmax(i) for i in Y_pred]

    incorr = [i for i in range(len(Y_test)) if Y_test[i] != Y_pred[i]]
    print(f"FOR {i.upper()}, INCORRECT PREDICTIONS = {len(incorr)} / 10000\n")

